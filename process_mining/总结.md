# 流程挖掘问题诊断与解决方案

## 🎯 您的问题

根据您提供的 Petri 网截图，流程挖掘结果显示：
- 所有活动（挂号、开方发布、配药、发药、检查、取报告一次、取报告诊断、收费、开单、开方）都发散连接
- 缺少清晰的流程顺序
- 不符合正常医疗流程的逻辑

## 🔍 根本原因

**Case ID (挂号ID) 使用错误！**

您在原始问题中提到：
> "这边是一个流程就是一个挂号id，把相同挂号id的事件串起来就行"

但实际数据中可能：
1. 使用了 `USER_ID: "2400"` 作为 Case ID
2. 而不是使用真正的挂号ID

### 为什么这是问题？

```
❌ 错误：使用用户ID作为Case ID
用户2400的所有就诊记录：
- 5月14日：挂号 → 检查 → 报告审核
- 5月15日：挂号 → 检查 → 诊断 → 开方
- 5月16日：挂号 → 开方 → 配药

ProM会认为这是一个案例，包含：
挂号 → 检查 → 报告审核 → 挂号 → 检查 → 诊断 → 开方 → 挂号 → 开方 → 配药

结果：流程混乱，无法识别正确的顺序

✅ 正确：使用挂号ID作为Case ID
挂号001: 挂号 → 检查 → 报告审核
挂号002: 挂号 → 检查 → 诊断 → 开方
挂号003: 挂号 → 开方 → 配药

结果：每次就诊是独立案例，流程清晰
```

## 📋 解决方案

### 方案 1: 使用正确的挂号ID列

如果您的数据中有独立的挂号ID列：

```python
# 确保使用挂号ID而不是用户ID
df = pd.read_excel('your_data.xlsx')

# 检查列名
print(df.columns)
# 应该有类似：['挂号ID', '用户ID', '活动名称', '开始时间', ...]

# 使用挂号ID作为Case ID
convert_to_xes(df, output_file='medical_process.xes')
```

### 方案 2: 如果没有挂号ID，需要生成

如果数据只有用户ID，需要根据业务逻辑生成挂号ID：

```python
import pandas as pd

df = pd.read_excel('your_data.xlsx')

# 方法A: 根据用户ID + 日期生成
df['开始时间'] = pd.to_datetime(df['开始时间'])
df['日期'] = df['开始时间'].dt.date
df['挂号ID'] = df['用户ID'].astype(str) + '_' + df['日期'].astype(str)

# 方法B: 根据时间间隔判断（更准确）
# 假设同一用户相邻事件超过4小时就是新的就诊
df = df.sort_values(['用户ID', '开始时间'])
df['时间差'] = df.groupby('用户ID')['开始时间'].diff().dt.total_seconds() / 3600

# 标记新就诊（时间差>4小时或第一条记录）
df['新就诊'] = (df['时间差'] > 4) | df['时间差'].isna()

# 生成挂号ID
df['就诊序号'] = df.groupby('用户ID')['新就诊'].cumsum()
df['挂号ID'] = df['用户ID'].astype(str) + '_V' + df['就诊序号'].astype(str)

# 删除辅助列
df = df.drop(['时间差', '新就诊', '就诊序号', '日期'], axis=1)

# 保存处理后的数据
df.to_excel('processed_data.xlsx', index=False)
```

### 方案 3: 数据清洗和标准化

```python
# 1. 标准化活动名称
activity_mapping = {
    '挂号': ['挂号', '门诊挂号', '预约挂号'],
    '检查': ['检查', '体检', '检验'],
    '报告审核': ['报告审核', '审核报告', '取报告一次', '取报告诊断'],
    '开方': ['开方', '开处方', '开方发布'],
    '配药': ['配药', '药房配药'],
    '发药': ['发药', '药房发药'],
    '收费': ['收费', '缴费', '结算'],
    '开单': ['开单', '开检查单']
}

for standard, variants in activity_mapping.items():
    df.loc[df['活动名称'].isin(variants), '活动名称'] = standard

# 2. 删除重复事件
df = df.drop_duplicates(subset=['挂号ID', '活动名称', '开始时间'])

# 3. 按时间排序
df = df.sort_values(['挂号ID', '开始时间'])

# 4. 过滤不完整的案例
events_per_case = df.groupby('挂号ID').size()
valid_cases = events_per_case[events_per_case >= 3].index
df = df[df['挂号ID'].isin(valid_cases)]
```

## 🚀 使用我提供的工具

我已经为您创建了完整的工具集：

### 1. 快速诊断（推荐第一步）

```bash
python diagnose_data.py your_data.xlsx
```

这会告诉您：
- Case ID 是否正确
- 每个案例的平均事件数（应该 > 2）
- 活动分布
- 流程变体

**关键输出：**
```
5. 挂号ID (Case ID) 分析:
   唯一挂号ID数量: 1000
   
   ✗ 警告: 每行都是不同的挂号ID！  ← 如果看到这个，说明有问题
      这意味着没有案例包含多个事件
```

### 2. 数据清洗

```bash
python clean_data_example.py your_data.xlsx cleaned_data.xlsx
```

### 3. 转换为 XES

```bash
python quick_start.py cleaned_data.xlsx
```

或直接：

```python
from convert_to_xes import convert_to_xes
import pandas as pd

df = pd.read_excel('cleaned_data.xlsx')
convert_to_xes(df, 'medical_process.xes')
```

### 4. 在 ProM 中分析

1. 打开 ProM
2. Import → `medical_process.xes`
3. 选择 **Inductive Miner** (推荐)
4. 可视化 Petri 网

## ✅ 预期结果

正确的 Petri 网应该显示：

```
[开始]
  ↓
挂号
  ↓
检查 ←→ 开单
  ↓
报告审核
  ↓
诊断
  ↓
开方
  ↓
配药
  ↓
发药
  ↓
收费
  ↓
[结束]
```

**特征：**
- ✓ 有清晰的主流程
- ✓ 活动按医疗逻辑排序
- ✓ 可能有分支（如：有些患者不需要检查直接开方）
- ✓ 大部分案例遵循相似路径

## 📊 数据要求总结

| 字段 | 说明 | 示例 |
|------|------|------|
| 挂号ID | **每次就诊的唯一ID**（不是用户ID！） | "REG20230514001" |
| 活动名称 | 流程步骤名称 | "挂号", "检查", "报告审核" |
| 开始时间 | 活动开始时间 | "2023-05-14 14:14:07" |
| 结束时间 | (可选) 活动结束时间 | "2023-05-14 14:18:03" |
| 角色 | (可选) 执行者角色 | "检查检验科医生" |
| 人员ID | (可选) 执行者ID | "检查检验科医生_P22" |

## 🔧 调试检查清单

如果转换后 ProM 仍显示错误的流程：

- [ ] 确认使用的是挂号ID而不是用户ID
- [ ] 检查每个案例的平均事件数（应该 > 2，理想 > 5）
- [ ] 确认活动名称已标准化（没有重复的相似名称）
- [ ] 确认数据已按时间排序
- [ ] 确认删除了不完整的案例
- [ ] 在 ProM 中使用 Inductive Miner 而不是 Alpha Miner

## 📁 文件清单

我为您创建了以下文件：

```
process_mining/
├── README.md                    # 英文文档
├── 使用指南.md                  # 中文详细指南
├── 总结.md                      # 本文件
├── requirements.txt             # Python 依赖
├── convert_to_xes.py           # XES 转换脚本（核心）
├── diagnose_data.py            # 数据诊断工具
├── clean_data_example.py       # 数据清洗示例
└── quick_start.py              # 一键运行脚本
```

## 🎯 下一步行动

1. **立即执行：**
   ```bash
   cd process_mining
   pip install -r requirements.txt
   python diagnose_data.py ../your_data.xlsx
   ```

2. **根据诊断结果：**
   - 如果 Case ID 正确 → 直接转换
   - 如果 Case ID 错误 → 先修正数据

3. **修正 Case ID（如果需要）：**
   ```python
   import pandas as pd
   
   df = pd.read_excel('your_data.xlsx')
   
   # 检查是否有真正的挂号ID列
   print(df.columns)
   
   # 如果没有，生成挂号ID
   df['开始时间'] = pd.to_datetime(df['开始时间'])
   df = df.sort_values(['USER_ID', '开始时间'])
   df['时间差'] = df.groupby('USER_ID')['开始时间'].diff().dt.total_seconds() / 3600
   df['新就诊'] = (df['时间差'] > 4) | df['时间差'].isna()
   df['就诊序号'] = df.groupby('USER_ID')['新就诊'].cumsum()
   df['挂号ID'] = df['USER_ID'].astype(str) + '_V' + df['就诊序号'].astype(str)
   
   # 保存
   df.to_excel('fixed_data.xlsx', index=False)
   ```

4. **转换和验证：**
   ```bash
   python quick_start.py fixed_data.xlsx
   ```

5. **在 ProM 中验证结果**

## 💡 关键要点

1. **挂号ID ≠ 用户ID**
   - 挂号ID：每次就诊一个ID
   - 用户ID：同一患者所有就诊共享

2. **每个案例应该包含多个事件**
   - 如果每个案例只有1个事件 → Case ID 错误
   - 正常应该有 3-10 个事件

3. **数据清洗很重要**
   - 标准化活动名称
   - 删除重复和不完整数据
   - 按时间排序

4. **选择合适的挖掘算法**
   - Inductive Miner：容错性强（推荐）
   - Alpha Miner：要求数据完美
   - Heuristic Miner：处理复杂流程

## 📞 如果还有问题

请提供：
1. `diagnose_data.py` 的完整输出
2. 数据的前10行（脱敏）
3. ProM 生成的 Petri 网截图
4. 您的数据中有哪些列

祝您流程挖掘成功！🎉




